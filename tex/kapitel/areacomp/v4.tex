% !TeX root = ../../main.tex
\section{AreaComp V4}

Dies ist nun die finale Version dieses Algorithmus. 

\subsection{Bessere Predecessor-Datenstruktur}

Bisher verwendete \texttt{RuleIntervalIndex} Red-Black-Trees als zugrundeliegende Predecessor-Datenstruktur. Zwar ist eine Laufzeit von $\mathcal{O}(\log n)$ für jede Operation der Predecessor-Datenstruktur nicht schlecht. Da aber etwa die $\texttt{get}$ und $\texttt{predecessor}$ Operation sehr oft aufgerufen werden, stellt dies ein Bottleneck für die Laufzeit dar.
Die Idee ist nun, Red-Black-Trees durch eine für diese Zwecke effizientere Datenstruktur zu ersetzen.

Dazu bietet sich die Predecessor-Datenstruktur aus \cite{dinklage_engineering_2021} an. Im weiteren Verlauf nennen wir diese \texttt{BucketPred}. Im Code für AreaComp ist sie unter demselben Namen zu finden. Wir nutzen allerdings hier eine assoziative Variante, die durch eine Hashtabelle gestützt wird. Diese Hashtabelle ist global. 
Eine lokale Hashtabelle für jeden Bucket, scheint bei Tests keine Vorteile zu bieten.\\
Durch diese Hashtabelle erhalten wir $\mathcal{O}(1)$ amortisierte Laufzeit für $\texttt{get}$ Operationen, $\mathcal{O}(b)$ Worst-Case Laufzeit für $\texttt{predecessor}$ Operationen und $\mathcal{O}(u \backslash b)$ Laufzeit für $\texttt{insert}$ Operationen. 

Wie in \cite{dinklage_engineering_2021} beschrieben, ist es ebenfalls möglich, das hier verwendete Array von Buckets durch eine Hashtabelle zu ersetzen. Dies würde für $\texttt{insert}$ Operationen eine amortisierte $\mathcal{O}(1)$ Laufzeit bedeuten, da nun nicht mehr im Array die $\mathcal{O}(u \backslash b)$ Pointer verändert werden müssen. Allerdings würde dies auch eine Laufzeit von $\mathcal{O}(u \backslash b)$ für $\texttt{predecessor}$ Operationen bedeuten, da potenziell $\mathcal{O}(u \backslash b)$ Anfragen an die Hashtabelle gestellt werden müssen, um einen aktiven Bucket zu finden. 

Allerdings wird $\texttt{predecessor}$ viel häufiger benötigt als $\texttt{insert}$ Operationen. Daher ist es von größerer Bedeutung, dass $\texttt{predecessor}$ Aufrufe performant sind. Daher eignet sich hier das Bucket-Array besser.

Da $u = |s|$ durch den Eingabestring $s$ gegeben ist, ist also die Wahl von $b = 2^k$, für ein $k \in \mathbb{N}$, interessant. Dieser widmen wir uns bei der Evaluation.
% TODO DAS AUCH MACHEN 

\subsection{Verbesserung von \texttt{RuleIntervalIndex}}

Wie bereits beschrieben, hat die vorherige Version von \texttt{RuleIntervalIndex} das Problem, dass bestimmte Fälle, in denen eine Substitution legal ist, nicht korrekt erkannt werden. Außerdem ist das Markieren von Bereichen noch ineffizient.  

Zu diesem Zweck verändern wir die Funktionsweise von \texttt{RuleIntervalIndex} etwas.
Wir speichern nun nicht mehr die am tiefsten verschachtelten Teile von Intervallen. Stattdessen speichern wir alle existierenden Intervalle. Dies tun wir auf eine Art und Weise, die es uns trotzdem ermöglicht, effizient das tiefste verschachtelte Intervall an einem Index zu finden, aber auch gegebenfalls weniger verschachtelte Intervalle. 

\subsubsection{Beispiel}

Betrachten wir wieder die Grammatik von zuvor für den String $abcdeabcd$:
\begin{align*}
	R_0 &\rightarrow R_1 c d e R_1 c d\\
	R_1 &\rightarrow a b\\
\end{align*}
Die neue Version der Datenstruktur sieht dann folgendermaßen aus:

\tikzset{
    table nodes/.style={
        rectangle,
        draw=black,
        align=center,
        minimum height=7mm,
        text depth=0.5ex,
        text height=2ex,
        inner xsep=0pt,
        outer sep=0pt
    },      
    table/.style={
        matrix of nodes,
        row sep=-\pgflinewidth,
        column sep=-\pgflinewidth,
        nodes={
            table nodes
        },
        execute at empty cell={\node[draw=none]{};}
    }
}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        
        \matrix (A) [table, text width=7mm] {
            $a$ & $b$ & $c$ & $d$ & $e$ & $a$ & $b$ & $c$ & $d$\\
            \\
            |[draw=none]| & |[draw=none]|  &  &  &  & |[draw=none]|  & |[draw=none]|  &  & |[draw=none]|\\
            |[draw=none]| & |[draw=none]|  &  &  &  & |[draw=none]|  & |[draw=none]|  &  & |[draw=none]|\\
        };
        
        
        \node[draw, fit=(A-3-1)(A-3-9), table nodes] {$R_0$-$[0..8]$};
        \node[draw, fit=(A-4-1)(A-4-2), table nodes] {$R_1$-$[0..1]$};
        \node[draw, fit=(A-4-6)(A-4-7), table nodes] {$R_1$-$[5..6]$};
    \end{tikzpicture}
    \caption{Die neue \texttt{RuleIntervalIndex} Struktur}
    \label{newrii}
\end{figure}

\subsubsection{Neue \texttt{RuleInterval} Attribute}

Die Intervalle behalten die Attribute $\texttt{ruleId}$, $\texttt{start}$ und $\texttt{end}$ Attribute. Die anderen Attribute werden durch die Folgenden ersetzt:

\begin{itemize}[leftmargin=3cm]
    \item[\texttt{parent}] Dies ist ein Pointer auf auf das am tiefsten verschachtelte Ersetzungsintervall, das dieses Intervall enthält. Dabei muss das $\texttt{parent}$ Intervall nicht unbedingt an demselben Startindex beginnen, wie das Intervall selbst. Im obigen Beispiel zeigt der \texttt{parent} Zeiger der beiden $R_1$ Intervalle auf das $R_0$ Intervall.
    \item[\texttt{firstAtStartIndex}] Ein Pointer auf das am \textit{wenigsten} verschachtelte Ersetzungsintervall, das an demselben Startindex beginnt, wie das Intervall selbst. Im Fall des Beispiels zeigen die \texttt{firstAtStartIndex} aller Intervalle jeweils auf sich selbst, da keine zwei Intervalle an demselben Index beginnen.
    \item[\texttt{nextAtStartIndex}] Ein Pointer auf das Ersetzungsintervall, das am selben Startindex beginnt und das nächst-tiefer verschachtelt ist
\end{itemize}

Die erste Idee war, in der zugrundeliegenden Predecessor-Struktur dynamische Arrays von $\texttt{RuleInterval}$s zu speichern. Dies war allerdings aufgrund des Speicherverbrauchs und des Laufzeit-Overhead von Allokationen und Reallokationen unhaltbar. Als Verbesserung sind die Elemente der Predecessor Struktur nun für jeden Index das jeweils das am tiefsten verschachtelte Intervall, das an diesem Startindex beginnt. Auf die anderen Intervalle, die an demselben Startindex beginnen, kann mithilfe der $\texttt{firstAtStartIndex}$, $\texttt{nextAtStartIndex}$ und $\texttt{parent}$ Pointer zugegriffen werden.

\subsubsection{Bestimmen der umschließenden Intervalle}
Wir können nun bestimmen, welches das tiefste verschachtelte Ersetzungsintervall ist, das ein Intervall $[i..j]$ umschließt.
Dies ist mithilfe des folgenden Algorithmus möglich.

\begin{algorithm}
	\caption{intervalContaining}
	\begin{algorithmic}
		\REQUIRE $from, to$ Start- und Endindizes
		\STATE $current \leftarrow floorInterval(from)$
		\WHILE {$current \neq \texttt{null}$}
			\IF {$current.start \leq from \textbf{ and } to \leq current.end$}
				\RETURN $current$
			\ENDIF
            \IF {$current.firstAtStartIndex \leq from \textbf{ and } to \leq current.firstAtStartIndex.end$}
                \STATE $current \leftarrow current.parent$
            \ELSE 
                \STATE $current \leftarrow current.firstAtStartIndex$
                \IF {$current.parent \neq \texttt{null}$}
                    \STATE $current \leftarrow current.parent$
                \ENDIF
            \ENDIF
		\ENDWHILE
		\RETURN \texttt{null}
	\end{algorithmic}
\end{algorithm}

Zuerst bestimmen wir mithilfe der zugrundeliegenden Predecessor Struktur das tiefste verschachtelte Vorgänger-Intervall des Startingindex $from$. 
In der While-Schleife wird nun geprüft, ob das jetzige Intervall auch beide Grenzen einschließt. Ist dies der Fall, so haben ist dies das tiefste Intervall, das das Intervall $[from..to]$ einschießt, gefunden.\\
Ist dies nicht der Fall, so wird nacheinander entlang der $\texttt{parent}$ Zeiger iteriert, bis ein Intervall gefunden wird, das beide Grenzen enthält. Da das Intervall der Startregel $R_0$ die ganze Länge des Eingabestring einnimmt, ist es also garantiert, dass solch ein Intervall auch existiert. Diese Methode kann auch das tiefste Intervall bestimmen, indem ein Index $i$ liegt, indem $\texttt{intervalContaining(i, i)}$ aufgerufen wird.

In dem Fall, dass selbst das am wenigsten verschachtelte Intervall an diesem Startindex (\texttt{firstAtStartIndex}) nicht die gegebenen Grenzen umschließt, so kann direkt zum Eltern-Intervall von \texttt{firstAtStartIndex} gesprungen werden, da somit keines der übersprungenen Intervalle die Grenzen umschließt. 

\subsubsection{Markieren von Ersetzungsintervallen}

Beim Markieren der Ersetzungsintervalle wird ein neues $\texttt{RuleInterval}$ $R_i$-$[start..end]$ in die Datenstruktur eingefügt. 
Zunächst, wird geprüft, ob es bereits ein Intervall gibt, das bei Startindex $start$ beginnt.
Hier muss zwischen verschiedenen Fällen unterschieden werden.

\begin{itemize}[leftmargin=1.5cm]
    \item[\textbf{Fall 1}] Falls kein solches Intervall existiert, so wird mithilfe von\\
    $\texttt{intervalContaining(start, end)}$ das Eltern-Intervall des neuen Intervalls bestimmt und der $\texttt{parent}$ Zeiger entsprechend gesetzt.  Es wird nun nur noch das Intervall in die Predecessor Datenstruktur eingefügt.
    \item[\textbf{Fall 2}] Im Fall, dass ein solches Intervall existiert, kann es nun sein, dass das neue Intervall das nun am tiefsten verschachtelte Intervall ist, das an diesem Startindex beginnt. Ist das der Fall, so werden die Pointer des entsprechenden Index gesetzt und das neue Intervall ersetzt nun das vorherige in der Predecessor Datenstruktur, da es nun das tiefste Intervall an diesem Index ist.\\
    Ist das Intervall nicht das tiefste an diesem Index, so kann durch die $\texttt{parent}$ Zeiger iteriert werden, bis ein Intervall an diesem Startindex gefunden wird, das das neue Intervall enthält. An diese Stelle muss dann das neue Intervall eingefügt werden. Es kann nun sein, das es kein solches Intervall gibt. Dann ist das neue Intervall, das größte und damit das am wenigsten verschachtelte Intervall, das an diesem Startindex beginnt. Ist das der Fall, so muss der $\texttt{firstAtStartIndex}$ aller Intervalle an diesem Startindex, auf das neue Intervall gesetzt werden. Dies kann während der ohnehin schon stattfindenden Iteration geschehen. 
\end{itemize} 

Es kann nun sein, dass durch das einfügen eines neuen Intervalls die $\texttt{parent}$ Zeiger anderer Intervalle fehlerhaft werden, da sich das neue Intervall zwischen das Eltern- und
Kindintervall schieben. Dies wird nun dadurch behoben, dass über alle Intervalle der Datenstruktur, die im Intervall $[start+1..end]$ liegen, iteriert wird. In dieser Iteration wird der \texttt{parent} Zeiger auf das neue Intervall gesetzt. 


\subsection{Ruleset}

Die Ruleset-Klasse ist für die Kompression des Strings verantwortlich. Das Ruleset beinhaltet eine Instanz der \texttt{RuleIntervalIndex} Datenstruktur. Sei im Folgenden $s \in \Sigma^*$ ein Eingabestring mit $n := |s|$ Dazu sind folgende Teilschritte erforderlich:

\subsubsection{Berechnen der benötigten Arrays}

Zunächst werden die benötigten Arrays berechnet. Mithilfe des QSufSort Algorithmus \cite{larsson_faster_2007} wird in $\mathcal{O}(n \log n)$ Laufzeit das Suffix-Array berechnet. Für das LCP-Array wird der Linearzeit Algorithmus aus \cite{kasai_linear-time_2001} verwendet. Zuletzt wird für die komprimierte Variante des Kind-Array der von Abouelhoda et al. beschriebene Algorithmus aus \cite{abouelhoda_optimal_2002} verwendet. Dieser berechnet das Kind-Array ebenfalls in $\mathcal{O}(n)$ Laufzeit.

\subsubsection{Berechnen der Prioritätswarteschlange}

Nun, da das Kind-Array berechnet ist, kann für jedes maximale LCP-Intervall mithilfe des von Abouelhoda et al. vorgestellten Algorithmus in $\mathcal{O}(1)$ die direkten Kind-Intervalle berechnet werden. Es existieren $\mathcal{O}(n)$ maximale LCP-Intervalle, da ein Index $i = 0,\dots,n - 1$ nicht gleichzeitig Startindex und Endindex von verschiedenen Intervallen sein kann. Insgesamt können alle maximalen LCP-Intervalle durch rekursive Aufrufe also in $\mathcal{O}(n)$ berechnet werden.

Diese Intervalle werden nun in eine auf einem Binären Heap \cite{williams_algorithm_1964} basierenden Prioritätswarteschlange eingefügt. Die benötigte Laufzeit um ein Element einzufügen oder das minimale/maximale Element zu entfernen ist $\mathcal{O}(\log n)$ im Worst-Case. Da die Aufrufe der Operationen der Prioritätswarteschlange keinen signifikanten Anteil der Laufzeit des Algorithmus ausmachen, ist es hier nicht nötig nach alternativen möglicherweise effizienteren Heap-Implementationen zu forschen.

Da die LCP-Intervalle anhand ihrer Flächenwerte priorisiert werden, muss die Flächenfunktion für jedes Intervall mindestens einmal aufgerufen werden. Sei $A$ die Flächenfunktion und $I$ ein LCP-Intervall. Sei dann die Laufzeit der Flächenfunktion $A(I)$ gleich $a(k)$, wobei $k = |I|$. 
Da die Länge jedes Intervalls $\mathcal{O}(n)$ ist, folgt insgesamt als Laufzeit für die Konstruktion der Prioritätswarteschlange: $\mathcal{O}(n \cdot a(n) \cdot \log n)$.\\\\

\subsubsection{Kompression}

Die folgenden Operationen werden solange wiederholt, bis die konstruierte Prioritätswarteschlange leer ist. 

\paragraph{Berechnung der Vorkommen}

Zuerst wird das Intervall $[i..j]$, $0 < i \leq j < n$ mit dem größten Flächenwert aus der Prioritätswarteschlange entnommen. Dann können die Indizes aller Vorkommen des Substrings in $SA[i-1..j]$ gefunden werden. Diese speichern wir in einem neuen Array $\texttt{positions}$, da diese Indizes noch nachbearbeitet werden müssen.

Die Länge des zu ersetzenden Substring $p \in \Sigma^*$ von $s$ ist dann gleich $k := |p| = \min_{i \leq a \leq j} LCP[a]$.
Dies kann in linearer Laufzeit berechnet werden, doch wir können uns hier die Eigenschaften der maximalen LCP-Intervalle und des Kind-Arrays zunutze machen. 
Wie in \cite{abouelhoda_optimal_2002} beschrieben, lässt sich der LCP-Wert eines maximalen LCP-Intervalls in $\mathcal{O}(1)$ Zeit bestimmen. Dies geschieht, indem mithilfe des $up$, beziehungsweise des $down$ Eintrages im Kind-Array, der erste $l$-Index des Intervalls bestimmt werden kann. Da an jedem $l$-Index im LCP-Array das Minimum über diesem Intervall enthält, ist damit die Länge des Substrings gefunden.

Somit sind sowohl die Vorkommen des Substrings, als auch dessen Länge berechnet. Ist $occ_p := j - i + 2$, die Anzahl an Vorkommen von $p$ in $s$. So benötigt diese Berechnung $\mathcal{O}(occ_p)$ Laufzeit, begrenzt durch die Berechnung der Indizes, an denen $p$ vorkommt.

\paragraph{Bereinigen der Indizes}

Nun ist es möglich, dass einige der Vorkommen sich nicht (mehr) für eine Ersetzung eignen. Etwa, weil diese sich mit dem vorhergehenden Vorkommen überlappen, oder weil dieses Vorkommen, die anderen nötigen Vorraussetzung für eine Substitution nicht erfüllen. Dies wurde in \ref{v3problems} und in der Beschreibung der neuen \texttt{RuleIntervalIndex} Datenstruktur genauer behandelt. Es werden nun mit den folgenden 2 Algorithmen, diejenigen Indizes entfernt, die nicht für eine Substitution in Frage kommen.

\subparagraph{substitutionAllowed}

Der erste Algorithmus bestimmt für ein Intervall, ob eine Substitution dieses Intervalls erlaubt ist. 

\begin{algorithm}
    \begin{algorithmic}
        \caption{substitutionAllowed}
        \REQUIRE $from, to: $ Start- und Endindizes, beide inklusiv,\\$intervalIndex: $ Die Instanz der \texttt{RuleIntervalIndex} Datenstruktur
        \STATE $ $
        \STATE $fromInterval \leftarrow intervalIndex.intervalContaining(from)$
        \WHILE{$from = fromInterval.start \textbf{ and } to > fromInterval.end \textbf{ and }$\\$fromInterval.parent \neq \texttt{null}$}
            \STATE $fromInterval \leftarrow fromInterval.parent$
        \ENDWHILE

        \IF{$to > fromInterval.end$}
            \RETURN \FALSE
        \ENDIF

        \STATE $toInterval \leftarrow intervalIndex.intervalContaining(to)$
        \WHILE{$toInterval$ does not contain $fromInterval \textbf{ and }$\\$to = toInterval.end \textbf{ and } toInterval.parent \neq null$}
            \STATE $toInterval \leftarrow toInterval.parent$
        \ENDWHILE
        \RETURN $toInterval = fromInterval$
    \end{algorithmic}
\end{algorithm}
Dieser Algorithmus prüft, ob das Intervall $[from..to]$ substituiert werden darf. Dazu prüft der Algorithmus, ob sich in genau einem Ersetzungsintervall zwei Symbole (Terminale oder Nichtterminale) finden lassen, dessen vollständig expandierte Form genau bei $from$ im Originalstring beginnt, beziehungsweise genau bei $to$ endet (inklusive des Zeichens).
In der Regel ist das Intervall das tiefste verschachtelte Intervall jeweils bei $from$ und $to$. 

Liegen $from$ oder $to$ innerhalb des tiefsten Intervalls an dem jeweiligen Index, so dürfen für den jeweiligen Index keine weniger verschachtelten Intervalle berücksichtigt werden, da sonst die Grenzen der tieferen Intervalle verletzt würden.\\ 
Fällt $from$ genau auf den Anfangsindex des tiefsten Intervalls, bei Index $from$, so kann dies ebenfalls bedeuten, dass der Index $from$ das Vorkommen eines Nichtterminals im $\texttt{parent}$ bezeichnen. Ist das der Fall, so ist es erlaubt ebenfalls die Elternintervalle mit zu berücksichtigen, solange $from$ der erste Index des jetzigen Intervalls ist. Gleiches gilt, wenn $to$ genau auf den Endindex des Intervalls fällt. Dann kann $to$ das Vorkommen eines Nichtterminals am \textit{Ende} des zu ersetzenden Bereiches in einer $\texttt{parent}$ Regel bezeichnen.

In diesen beiden Fällen gilt auch dasselbe wieder, falls $from$ auch im Elternintervall genau auf den Anfang fällt, beziehungsweise $to$ auch dort auf das Ende fällt.

Um dies besser zu veranschaulichen, hierzu ein Beispiel. Betrachten wir die folgende Grammatik für den String $abacaba$:

\begin{align*}
    S &\rightarrow AcA\\
    A &\rightarrow aba
\end{align*}

Die Methode liefert \texttt{true} für $from=0$ und $to=3$. Hier beschreibt der Index $0$ hier entweder das erste $a$ aus dem ersten Ersetzungsintervall der Regel $A$, oder das erste $A$ in der Regel $S$. Letzteres ist möglich, da der Index $0$ genau auf den Anfang des Ersetzungsintervalls $[0..2]$ der Regel $A$ fällt. Der Index $3$ kann hier nur $c$ beschreiben.
Es lassen sich hier also das erste $A$ als Startsymbol, und das $c$ als Endsymbol finden, die beide in dem einen Ersetzungsintervall der Regel $S$ liegen. Damit ist die Ersetzung von $Ac$ in der Regel $S$ erlaubt.

Für $from=1$ und $to=3$ liefert die Methode allerdings \texttt{false}. Der Index $3$ liefert wie im vorhergehenden Fall wieder nur das $c$ aus Regel $S$.
Index $1$ allerdings, liefert nur das $b$ aus dem ersten Ersetzungsintervall der Regel $A$. Hier dürfen keine weniger tiefen Ersetzungsintervalle (in diesem Fall nur das Eine der Regel $S$) berücksichtigt werden, da der Index $1$ nicht der Anfangsindex des Ersetzungsintervalls ist, in dem dieser Index liegt.
Wir haben als Wahl für das Startsymbol nur $b$ aus Regel $A$ und als Endsymbol nur das $c$ aus Regel $S$. Hier lassen sich also kein Paar von Start- und Endsymbolen finden, die in demselben Ersetzungsintervall liegen. Die Substitution ist als ungültig.

Für $from=0$ und $to=5$ liefert die Methode ebenfalls \texttt{false}. Hier liefert der Index $0$ wie im ersten Fall wieder $a$ aus dem ersten Ersetzungsintervall der Regel $A$ und das erste $A$ in der Regel $S$. Index $5$ liefert hier nur das $b$ aus dem \textit{zweiten} Ersetzungsintervall der Regel $A$. 
Da wir als Wahl für das Endsymbol nur das $b$ aus einem Ersetzungsintervall der Regel $A$ zur Verfügung haben, kommt für das Startsymbol nur das $a$ infrage, da das $A$ aus einem Ersetzungsintervall der Regel $S$ stammt.
Allerdings ist die Kombination von $a$ als Startsymbol und $b$ als Endsymbol ebenfalls ungültig, da diese jeweils aus unterschiedlichen Ersetzungsintervallen stammen.
Die Substitution ist hier also auch ungültig.

\subparagraph{cleanPositions}

Mit dem vorherigen Algorithmus lassen sich nun die gegebenen Indizes der Vorkommen von $p$ bereinigen, sodass nur noch Indizes übrig bleiben, bei denen es auch tatsächlich möglich ist, das Vorkommen zu ersetzen.  

\begin{algorithm}
    \begin{algorithmic}
        \caption{cleanPositions}
        \REQUIRE $positions: $ Array von Indizes an denen $p$ vorkommt, $len: $ Länge von $p$
    \end{algorithmic}
\end{algorithm}