% IMPORT-DATA dna dna.txt
% IMPORT-DATA proteins proteins.txt
% IMPORT-DATA xml dblp.xml.txt
% IMPORT-DATA english english.txt

\pgfplotsset{
    dataplot/.style={
        xtick={1,2,3,4,5},
        xticklabels={10,20,30,40,50},
        xticklabel style={align=center},
        xlabel={Größe der Eingabe},
        x unit={MB},
        width=7cm,
        height=6cm,,
        legend style={at={(1,1)}, anchor=north west}
    },
    runtimeplot/.style={
        dataplot,
        y unit={s},
        ylabel={Laufzeit},
        ytick distance=50
    },
    sizeplot/.style={
        dataplot,
        y unit={outputsize/inputsize},
        ylabel={Größenverhältnis},
        ytick distance=0.1
    },
    depthplot/.style={
        dataplot,
        y unit={\#Schritte zur tiefsten Regel},
        ylabel={Tiefe}
    },
}


\chapter{Evaluation}

\section{Methodik}

Bei der Evaluation der Algorithmen werden Sequitur (siehe \autoref{sequitur}), RePair (siehe \autoref{repair}) und AreaComp V4 (siehe \autoref{v4}) mit verschiedenen Flächenfunktionen auf verschiedene Datensätze angewendet. 

Nach der Berechnung der Algorithmus-spezifischen Repräsentation der Grammatik, wird diese in eine einheitliche Repräsentation überführt. Diese besteht lediglich aus einer Hashtabelle, die Regel-IDs auf eine Liste abbildet, die die Symbole der rechten Seite der Regel enthält. Die dafür benötigte Zeit wird ebenfalls in den Diagrammen aufgeführt. Die Zeit für den Algorithmus selbst ist in der Legende als \emph{Compute} bezeichnet, das überführen in die einheitliche Repräsentation als \emph{Unify}.

Die Algorithmen werden auf einem Windows 10 Gerät ausgeführt mit einem AMD Ryzen 5 2600X Prozessor (6 physische Kerne bei 3.6GHz) und 16GB RAM.

\subsection{Implementationen}

Die hier gewählte Implementation von Sequitur ist die Java-Implementation von Professor Eibe Frank\footnote{\url{http://www.sequitur.info/java}}. 

Für RePair wird eine eigene Implementation benutzt. Die meisten Implementationen waren in nicht JVM-Kompatiblen Programmiersprachen geschrieben. 
Die einzige auffindbare JVM-kompatible Implementation, war eine Kotlin-Implementierung von Dale King \footnote{\url{https://gitlab.com/NobleworksSoftware/RePair}}. Allerdings ist diese für größere Grammatiken nicht verwendbar, da sie UTF-16 Codepoints als Nichtterminale verwendet. Da Diese auf Zahlen unter $\mathtt{0x110000}$ begrenzt sind, ist diese Implementation nicht auf die hier verwendeten Testdaten anwendbar.

AreaCompV4 ist in Java 16 programmiert.

\subsection{Datensätze}

Die hier gewählten Datensätzen stammen aus dem Pizza\&Chili Corpus\footnote{\url{http://pizzachili.dcc.uchile.cl}}. Die Algorithmen werden jeweils auf 10MB und 50MB Präfixe folgender Datensätze:

\begin{itemize}
    \item[\emph{dna}] DNA Sequenzen von Project Gutenberg\footnote{\label{footnotegutenberg}\url{https://www.gutenberg.org}}. Jedes Basenpaar wird jeweils durch einen der Großbuchstaben \emph{A}, \emph{G}, \emph{C} und \emph{T} dargestellt. Zudem kommen einige Sonderzeichen vor. Das Alphabet besteht aus 16 Zeichen.
    \item[\emph{english}] Englischer Text von Project Gutenberg\footnoteref{footnotegutenberg}. Das Alphabet besteht aus 239 Zeichen.
    \item[\emph{proteins}] Proteinsequenzen aus der Swissprot Datenbank\footnote{\url{ftp://ftp.ebi.ac.uk/pub/databases/swissprot/release_compressed/uniprot_sprot.dat.gz}}. Jede Aminosäure ist mit jeweils einem Buchstaben kodiert. Das Alphabet besteht aus 27 Zeichen.
    \item[\emph{xml}] Eine XML-Datei mit Informationen über große Informatik-Zeitschriften etc. von der Universität Trier\footnote{\url{https://dblp.uni-trier.de}}. Das Alphabet besteht aus 97 Zeichen.
\end{itemize}

\subsection{Flächenfunktion}

Wir betrachten vier Flächenfunktionen. Diese machen sich die Eigenschaften der Abouelhoda-Intervalle zunutze. 
Wie in \cite{abouelhoda_optimal_2002} beschrieben, lässt sich der minimale LCP-Wert eines Abouelhoda-Intervalls $[i..j]$ durch $down[i]$ oder $up[j+1]$ im Kind-Array bestimmen. 
So muss nicht in Linearzeit durch das Intervall iteriert werden, um das Minimum zu bestimmen. Es kann stattdessen durch eine Konstantzeit-Anfrage an das Kind-Array bestimmt werden. Dies ist erst ab V3 möglich, da V1 und V2 beliebige LCP-Intervalle benutzen, da diese Operationen nur für Abouelhoda-Intervalle funktionieren.

Für alle folgenden Flächenfunktionen gilt, dass wenn $H(i+1, j) \leq 1$ gilt(siehe \autoref{areacompconcept} für die Definition von $H$ und $W$), als resultierender Flächenwert automatisch $0$ zurückgegeben wird. Da LCP-Intervalle mit Höhe $\leq 1$ einen Substring einer Länge von maximal $1$ beschreiben, sind diese für unsere Zwecke unnütz.  

Im Folgenden sei $I := [i..j]$ ein Abouelhoda-Intervall. Dann ist $LCP[i+1..j]$ das zugehörige LCP-Intervall und seien $h := H(i+1, j)$ und $w := W(i+1, j)$:

\begin{itemize}[leftmargin=3.3cm]
    \item[\texttt{ChildArea}] $A(I) = h \cdot w$\\
    Diese Flächenfunktion schätzt die erreichbare Kompression durch eine Multiplikation der Anzahl der Vorkommen ($w$) mit der Länge des ersetzten Substrings ($h$) ab.
    \item[\texttt{WidthFirstArea}] $A(I) = w$\\ Hier wird allein die Anzahl der Vorkommen Priorisiert.
    \item[\texttt{HeightFirstArea}] $A(I) = h$\\
    Hier wird allein die Länge des zu ersetzenden Substrings priorisiert.
    \item[\texttt{HeightAdvantageArea}] $A(I) = 10 \cdot h + \min\{\log(w), 9\}$\\ Diese Flächenfunktion ist der Versuch einer Verbesserung von \\
    \texttt{HeightFirstArea}. Da bei \texttt{HeightFirstArea} allein die Höhe des LCP-Intervalls berücksichtigt wird, ist es möglich, dass LCP-Intervalle vor anderen LCP-Intervallen mit gleicher Höhe aber größerer Breite gewählt werden. Allerdings sind aber Letztere a priori vielversprechender. Hier wird also logarithmisch die Breite in die Berechnung miteingebracht und dieser Wert auf maximal $9$ begrenzt. Da die Höhe mit dem Faktor $10$ multipliziert wird, wird hier sichergestellt, dass keine Intervalle vor einem anderen Intervall mit größerer Höhe gewählt werden.
\end{itemize}



\section{Ergebnisse}

\subsection{dna}

Der \emph{dna} zeichnet sich durch sein besonders kleines Alphabet von nur 16 Zeichen aus. Die Ergebnisse der Algorithmenaufrufe sind in \autoref{resultsdna} zu sehen. 

\subsubsection{Laufzeit}

In \autoref{resultsdnaruntime} sehen wir, dass im Bezug auf Laufzeit, Sequitur und RePair am besten funktionieren. AreaComp hat mit den Flächenfunktionen \texttt{HeightFirstArea} und \texttt{HeightAdvantageArea}. AreaComp mit den Flächenfunktionen \texttt{ChildArea} und \texttt{WidthFirstArea} sind nur etwa halb so schnell. 
Während Sequitur, Repair und AreaComp mit den ersten beiden genannten Flächenfunktionen einen linearen Anstieg in der Laufzeit zeigen, hat AreaComp mit den letzteren beiden Flächenfunktionen einen viel steileren Anstieg, insbesondere wenn die Eingabedatenmenge von $30$MB auf $40$MB steigt.

\subsubsection{Grammatikgröße}



% DNA PLOT
\begin{figure}
    \centering

    \subfloat[Laufzeiten]{
        \begin{tikzpicture}
            \begin{axis}[runtimeplot, title={DNA Laufzeit}]

               
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG((comptime + unifytime) / 1000) AS y, MULTIPLOT
                %% FROM dna GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,47.0) (2,106.0) (3,171.0) (4,232.0) (5,314.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,51.0) (2,116.0) (3,198.0) (4,282.0) (5,380.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,50.0) (2,117.0) (3,190.0) (4,266.0) (5,368.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,44.0) (2,103.0) (3,159.0) (4,227.0) (5,306.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,15.0) (2,35.0) (3,57.0) (4,75.0) (5,102.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,4.0) (2,9.0) (3,15.0) (4,23.0) (5,31.0) };
                \addlegendentry{algo=Sequitur};
                
            \end{axis}
        \end{tikzpicture}
        \label{resultsdnaruntime}
    }
    \quad
    \subfloat[Größe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[sizeplot, title={DNA Grammatikgröße}]

                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, MIN(size / (1.0 * inputsize)) AS y, MULTIPLOT 
                %% FROM dna GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,0.429266) (2,0.429114) (3,0.429129) (4,0.429873) (5,0.429092) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,0.216447) (2,0.205636) (3,0.201329) (4,0.197742) (5,0.194624) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,0.218332) (2,0.207557) (3,0.203194) (4,0.199581) (5,0.19631) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,0.429441) (2,0.429373) (3,0.429393) (4,0.430037) (5,0.429272) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,0.647652) (2,0.527011) (3,0.640813) (4,0.53727) (5,0.516707) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,0.146958) (2,0.139801) (3,0.138794) (4,0.137584) (5,0.135546) };
                \addlegendentry{algo=Sequitur};
                

            \end{axis}
        \end{tikzpicture}
        \label{resultsdnasize}
    }
    \quad
    \subfloat[Tiefe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[depthplot, title={DNA Grammatiktiefe}, ymode=log]

                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG(depth) AS y, MULTIPLOT 
                %% FROM dna GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,7.0) (2,7.0) (3,9.0) (4,9.0) (5,9.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,48.0) (2,52.0) (3,58.0) (4,58.0) (5,58.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,49.0) (2,51.0) (3,57.0) (4,58.0) (5,57.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,3.0) (2,3.0) (3,3.0) (4,3.0) (5,3.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,335.0) (2,532.0) (3,2403.0) (4,1635.0) (5,3034.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,11.0) (2,11.0) (3,12.0) (4,12.0) (5,12.0) };
                \addlegendentry{algo=Sequitur};
            
                

            \end{axis}
        \end{tikzpicture}
        \label{resultsdnadepth}
    }
    \caption{Die Ergebnisse für die Kompression des \emph{dna} Datensatzes aus dem Pizza\&Chili Corpus. In \autoref{resultsdnaruntime} ist die Laufzeit der verschiedenen Algorithmen auf den jeweiligen Präfixen dieses Datensatzes zu sehen. In \autoref{resultsdnasize} ist die Größe der Verhältnis im Verhältnis zu der Größe der Eingabe dargestellt. Die Werte sind die jeweiligen Quotienten von der Größe der Grammatik und der Anzahl der Zeichen in der Eingabe. \autoref{resultsdnadepth} zeigt die Tiefe der erzeugten Grammatiken.}
    \label{resultsdna}
\end{figure}


\subsection{proteins}

% PROTEINS PLOT
\begin{figure}
    \centering

    \subfloat[Laufzeiten]{
        \begin{tikzpicture}
            \begin{axis}[runtimeplot, title={Proteins Laufzeit}]

               
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG((comptime + unifytime) / 1000) AS y, MULTIPLOT
                %% FROM proteins GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,43.0) (2,97.0) (3,135.0) (4,167.0) (5,214.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,40.0) (2,87.0) (3,125.0) (4,159.0) (5,202.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,39.0) (2,86.0) (3,131.0) (4,161.0) (5,205.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,39.0) (2,84.0) (3,118.0) (4,154.0) (5,192.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,16.0) (2,42.0) (3,79.0) (4,92.0) (5,123.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,6.0) (2,15.5) (3,27.0) (4,40.0) (5,58.0) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsproteinsruntime}
    }
    \quad
    \subfloat[Größe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[sizeplot, title={Proteins Grammatikgröße}]

                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, MIN(size / (1.0 * inputsize)) AS y, MULTIPLOT 
                %% FROM proteins GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,0.341726) (2,0.365969) (3,0.386289) (4,0.400567) (5,0.404739) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,0.212851) (2,0.202009) (3,0.222857) (4,0.249495) (5,0.264087) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,0.21661) (2,0.20566) (3,0.227152) (4,0.254638) (5,0.269725) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,0.433566) (2,0.432746) (3,0.432112) (4,0.43228) (5,0.432293) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,0.767845) (2,0.776813) (3,0.744482) (4,0.834881) (5,0.828773) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,0.179865) (2,0.169194) (3,0.180369) (4,0.198115) (5,0.208265) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsproteinssize}
    }
    \quad
    \subfloat[Tiefe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[depthplot, title={Proteins Grammatiktiefe}, ymode=log]
                
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG(depth) AS y, MULTIPLOT 
                %% FROM proteins GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,36.0) (2,43.0) (3,47.0) (4,49.0) (5,50.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,53.0) (2,59.0) (3,62.0) (4,64.0) (5,64.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,50.0) (2,52.0) (3,62.0) (4,64.0) (5,64.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,3.0) (2,4.0) (3,4.0) (4,4.0) (5,4.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,1628.0) (2,2819.0) (3,3413.0) (4,2982.0) (5,3733.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,20.0) (2,24.0) (3,24.0) (4,24.0) (5,24.0) };
                \addlegendentry{algo=Sequitur};
                
            \end{axis}
        \end{tikzpicture}
        \label{resultsproteinsdepth}
    }
    \caption{Die Ergebnisse für die Kompression des \emph{proteins} Datensatzes aus dem Pizza\&Chili Corpus. In \autoref{resultsproteinsruntime} ist die Laufzeit der verschiedenen Algorithmen auf den jeweiligen Präfixen dieses Datensatzes zu sehen. In \autoref{resultsproteinssize} ist die Größe der Verhältnis im Verhältnis zu der Größe der Eingabe dargestellt. Die Werte sind die jeweiligen Quotienten von der Größe der Grammatik und der Anzahl der Zeichen in der Eingabe. \autoref{resultsproteinsdepth} zeigt die Tiefe der erzeugten Grammatiken.}
    \label{resultsproteins}
\end{figure}

% XML PLOT
\begin{figure}
    \centering

    \subfloat[Laufzeiten]{
        \begin{tikzpicture}
            \begin{axis}[runtimeplot, title={XML Laufzeit}]
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG((comptime + unifytime) / 1000) AS y, MULTIPLOT
                %% FROM xml GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,41.0) (2,91.0) (3,145.0) (4,203.0) (5,269.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,35.0) (2,83.0) (3,135.0) (4,202.0) (5,265.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,35.0) (2,85.0) (3,139.0) (4,192.0) (5,250.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,35.0) (2,78.0) (3,125.0) (4,174.0) (5,232.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,11.0) (2,29.0) (3,45.0) (4,63.0) (5,80.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,4.0) (2,9.0) (3,15.0) (4,22.0) (5,29.0) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsxmlruntime}
    }
    \quad
    \subfloat[Größe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[sizeplot, title={XML Grammatikgröße}]

                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, MIN(size / (1.0 * inputsize)) AS y, MULTIPLOT 
                %% FROM xml GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,0.150608) (2,0.153637) (3,0.157878) (4,0.157854) (5,0.166147) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,0.086619) (2,0.0805638) (3,0.078124) (4,0.0753391) (5,0.0757765) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,0.088598) (2,0.0824666) (3,0.0799382) (4,0.0771623) (5,0.0775188) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,0.29432) (2,0.29514) (3,0.298642) (4,0.30164) (5,0.366257) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,0.266995) (2,0.277118) (3,0.258805) (4,0.280782) (5,0.304951) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,0.0779639) (2,0.0725272) (3,0.0702591) (4,0.0670736) (5,0.0680445) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsxmlsize}
    }
    \quad
    \subfloat[Tiefe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[depthplot, title={XML Grammatiktiefe}, ymode=log]
                
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG(depth) AS y, MULTIPLOT 
                %% FROM xml GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,17.0) (2,16.0) (3,17.0) (4,17.0) (5,16.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,28.0) (2,33.0) (3,36.0) (4,36.0) (5,36.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,26.0) (2,31.0) (3,34.0) (4,33.0) (5,33.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,7.0) (2,8.0) (3,7.0) (4,7.0) (5,7.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,85.0) (2,116.0) (3,180.0) (4,155.0) (5,243.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,19.0) (2,19.0) (3,19.0) (4,19.0) (5,19.0) };
                \addlegendentry{algo=Sequitur};
                
            \end{axis}
        \end{tikzpicture}
        \label{resultsxmldepth}
    }
    \caption{Die Ergebnisse für die Kompression des \emph{xml} Datensatzes aus dem Pizza\&Chili Corpus. In \autoref{resultsxmlruntime} ist die Laufzeit der verschiedenen Algorithmen auf den jeweiligen Präfixen dieses Datensatzes zu sehen. In \autoref{resultsxmlsize} ist die Größe der Verhältnis im Verhältnis zu der Größe der Eingabe dargestellt. Die Werte sind die jeweiligen Quotienten von der Größe der Grammatik und der Anzahl der Zeichen in der Eingabe. \autoref{resultsxmldepth} zeigt die Tiefe der erzeugten Grammatiken.}
    \label{resultsxml}
\end{figure}

% ENGLISH PLOT
\begin{figure}
    \centering

    \subfloat[Laufzeiten]{
        \begin{tikzpicture}
            \begin{axis}[runtimeplot, title={English Laufzeit}]
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG((comptime + unifytime) / 1000) AS y, MULTIPLOT
                %% FROM english GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,44.0) (2,113.0) (3,162.0) (4,231.0) (5,297.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,47.0) (2,114.0) (3,174.0) (4,244.0) (5,315.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,46.0) (2,114.0) (3,177.0) (4,242.0) (5,333.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,37.0) (2,89.0) (3,138.0) (4,192.0) (5,246.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,30.0) (2,77.0) (3,121.0) (4,168.0) (5,209.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,5.0) (2,13.0) (3,23.0) (4,34.0) (5,47.0) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsenglishruntime}
    }
    \quad
    \subfloat[Größe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[sizeplot, title={English Grammatikgröße}]

                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, MIN(size / (1.0 * inputsize)) AS y, MULTIPLOT 
                %% FROM xml GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,0.150608) (2,0.153637) (3,0.157878) (4,0.157854) (5,0.166147) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,0.086619) (2,0.0805638) (3,0.078124) (4,0.0753391) (5,0.0757765) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,0.088598) (2,0.0824666) (3,0.0799382) (4,0.0771623) (5,0.0775188) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,0.29432) (2,0.29514) (3,0.298642) (4,0.30164) (5,0.366257) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,0.266995) (2,0.277118) (3,0.258805) (4,0.280782) (5,0.304951) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,0.0779639) (2,0.0725272) (3,0.0702591) (4,0.0670736) (5,0.0680445) };
                \addlegendentry{algo=Sequitur};
            \end{axis}
        \end{tikzpicture}
        \label{resultsenglishsize}
    }
    \quad
    \subfloat[Tiefe der erzeugten Grammatik]{
        \begin{tikzpicture}
            \begin{axis}[depthplot, title={English Grammatiktiefe}, ymode=log]
                
                %% MULTIPLOT(algo) SELECT SUBSTR(datasetsize, 1, 1) AS x, AVG(depth) AS y, MULTIPLOT 
                %% FROM xml GROUP BY MULTIPLOT, datasetsize
                \addplot coordinates { (1,17.0) (2,16.0) (3,17.0) (4,17.0) (5,16.0) };
                \addlegendentry{algo=AreaCompV4/ChildArea};
                \addplot coordinates { (1,28.0) (2,33.0) (3,36.0) (4,36.0) (5,36.0) };
                \addlegendentry{algo=AreaCompV4/HeightAdvantageArea};
                \addplot coordinates { (1,26.0) (2,31.0) (3,34.0) (4,33.0) (5,33.0) };
                \addlegendentry{algo=AreaCompV4/HeightFirstArea};
                \addplot coordinates { (1,7.0) (2,8.0) (3,7.0) (4,7.0) (5,7.0) };
                \addlegendentry{algo=AreaCompV4/WidthFirstArea};
                \addplot coordinates { (1,85.0) (2,116.0) (3,180.0) (4,155.0) (5,243.0) };
                \addlegendentry{algo=RePair};
                \addplot coordinates { (1,19.0) (2,19.0) (3,19.0) (4,19.0) (5,19.0) };
                \addlegendentry{algo=Sequitur};
                
            \end{axis}
        \end{tikzpicture}
        \label{resultsenglishdepth}
    }
    \caption{Die Ergebnisse für die Kompression des \emph{english} Datensatzes aus dem Pizza\&Chili Corpus. In \autoref{resultsenglishruntime} ist die Laufzeit der verschiedenen Algorithmen auf den jeweiligen Präfixen dieses Datensatzes zu sehen. In \autoref{resultsenglishsize} ist die Größe der Verhältnis im Verhältnis zu der Größe der Eingabe dargestellt. Die Werte sind die jeweiligen Quotienten von der Größe der Grammatik und der Anzahl der Zeichen in der Eingabe. \autoref{resultsenglishdepth} zeigt die Tiefe der erzeugten Grammatiken.}
    \label{resultsenglish}
\end{figure}
